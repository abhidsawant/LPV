//DL1

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import warnings
warnings.filterwarnings('ignore')

df = pd.read_csv("housing_data.csv")
df.head()
df.describe()
df.info()
df.columns
df.head()
df.isnull().sum()
df = df.dropna()
df.isnull().sum()

plt.figure(figsize = (12,10), dpi = 250)
sns.heatmap(df.corr(), cmap = 'coolwarm', annot = True)
plt.show()


X = df[['LSTAT','RM']]
Y = df["MEDV"]
X.shape,Y.shape

from sklearn.model_selection import train_test_split
x_train,x_test,y_train,y_test = train_test_split(X,Y,test_size=0.25,random_state=69)

from sklearn.preprocessing import StandardScaler
scaler = StandardScaler()

x_train = scaler.fit_transform(x_train)
x_test = scaler.fit_transform(x_test)

from keras.models import Sequential
from keras.layers import Dense

model = Sequential()
model.add(Dense(128,input_shape=(2,),activation='relu',name='input'))
model.add(Dense(64,activation='relu',name='layer_1'))
model.add(Dense(1,activation='linear',name='output'))
model.compile(optimizer='adam', loss='mse', metrics=['mae'])
model.summary()

history = model.fit(x_train,y_train,epochs=100,validation_split=0.5)

output = model.evaluate(x_test,y_test)

print(f"Mean Squared Error: {output[0]}")
print(f"Mean Absolute Error: {output[1]}")

y_pred = model.predict(x=x_test)

sns.regplot(x = y_test, y = y_pred, ci = None)

from sklearn import metrics
print(f"MAE is {metrics.mean_absolute_error(y_test, y_pred)}")
print(f"MSE is {metrics.mean_squared_error(y_test, y_pred)}")
print(f"R2 score is {metrics.r2_score(y_test,y_pred)}")

plt.plot(history.history['loss'], label='Training Loss')
plt.plot(history.history['val_loss'], label='Validation Loss')
plt.plot(history.history['mae'], label='MAE')
plt.title('Training and Validation loss')
plt.xlabel('Epoch')
plt.ylabel('Loss')
plt.legend()
plt.show()

y_pred = model.predict(np.array([[6.575, 4.98]]))

y_pred

df['MEDV'].mean()

import keras
model = Sequential()
model.add(Dense(128,input_shape=(2,),activation='relu',name='input'))
model.add(Dense(64,activation='relu',name='layer_1'))
model.add(Dense(1,activation='linear',name='output'))
model.compile(optimizer=keras.optimizers.Adam(learning_rate=5e-3), loss='mse', metrics=['mae'])
model.summary()

plt.plot(history_lr5.history['loss'], label='Training Loss')
plt.plot(history_lr5.history['val_loss'], label='Validation Loss')
plt.plot(history_lr5.history['mae'], label='MAE')
plt.title('Training and Validation loss')
plt.xlabel('Epoch')
plt.ylabel('Loss')
plt.legend()
plt.show()


//FASHION_DATASET
import tensorflow as tf
import matplotlib.pyplot as plt
from tensorflow import keras
import numpy as np
from tqdm.notebook import tqdm

(x_train, y_train), (x_test, y_test) = keras.datasets.fashion_mnist.load_data()

plt.imshow(x_train[0])

plt.imshow(x_train[5])

plt.imshow(x_train[3])

x_train = x_train.astype('float32') / 255.0
x_test = x_test.astype('float32') / 255.0
x_train = x_train.reshape(-1, 28, 28, 1)
x_test = x_test.reshape(-1, 28, 28, 1)

x_train.shape

x_test.shape

y_train.shape

y_test.shape

model = keras.Sequential([
    keras.layers.Conv2D(32, (3,3), activation='relu', input_shape=(28,28,1)),
    keras.layers.MaxPooling2D((2,2)),
    keras.layers.Dropout(0.25),
    keras.layers.Conv2D(64, (3,3), activation='relu'),
    keras.layers.MaxPooling2D((2,2)),
    keras.layers.Dropout(0.25),
    keras.layers.Conv2D(128, (3,3), activation='relu'),
    keras.layers.Flatten(),
    keras.layers.Dense(128, activation='relu'),
    keras.layers.Dropout(0.25),
    keras.layers.Dense(10, activation='softmax')
])

model.compile(optimizer='adam', loss='sparse_categorical_crossentropy', metrics=['accuracy'])

model.summary()

batch_size = 64
epochs = 15

history_list = []
with tqdm(total=epochs, desc="Training Progress") as pbar:
    for epoch in range(epochs):
        history = model.fit(x_train, y_train, batch_size=batch_size, epochs=1, verbose=0, validation_data=(x_test, y_test))
        history_list.append(history.history)
        pbar.update(1)

val_accuracy = history_list[-1]['val_accuracy'][0]
print('Validation Accuracy (last epoch):', val_accuracy)

score = model.evaluate(x_test, y_test, verbose=0)
print('Test loss:', score[0])
print('Test accuracy:', score[1])



  
